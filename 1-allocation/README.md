#### 内存分配
go语言有着部分c语言的部分血统，在了解go语言的内存分配之前，先回顾下c语言内存分配的细节：
1. c语言中变量类型主要有如下几种类型：
    - 全局变量和静态变量：主要分配在数据区
    - 局部变量：主要分为两类：
        - 自动分配的局部变量：分配在栈上。主要有函数的参数、函数的局部变量
        - 手动分配的局部变量：分配在堆上。通过malloc去显式的分配内存
2. 因为c语言没有垃圾回收器（gc），需要用户主动地去管理内存。
    - 全局变量和静态变量，随着程序的启动而初始化，随着程序的退出而销毁
    - 局部变量：
        - 自动分配：随着函数的调用而自动分配，并随着函数的返回而自动销毁
        - 手动分配：这个需要用户自己来管理，否则轻则内存泄漏，重则panic，用户必须在适当的地方调用free释放分配的内存
3. 大多数用户不能有效地管理内存，而因为内存分配及回收的导致的问题层出不穷，所以go语言选择了另一种方式：
	- go语言自动管理程序中分配的内存，并在适当的时机完成对无效内存的回收
4. go语言实现了内存的自动分配及回收，减轻用户负担的同时，也提升了程序的安全性，但也带来了一些问题：
	- 变量的不同分配方式，它们的代价也不相同：每个goroutine都有部分私有空间，因此分配在栈上的代价非常小；然而堆是所有goroutine共享的，在这里分配内存的代价则要高出很多
	- 用户如何确定这个变量到底是分配在栈上，还是分配在堆上：参考第5点
	- 由变量分配造成的高代价如何避免：优化代码结构
    - 所以说，垃圾回收并不是彻底解放用户的双手，搞清楚原理能够帮助用户写出更加高效的程序
    - 但是，一般来说，除非遇到性能问题，否则不需要刻意去进行分析优化（学知识就另论了，技多不压身嘛）
5. go语言使用一种[逃逸分析](https://en.wikipedia.org/wiki/Escape_analysis)的机制，来判断变量是否能够分配在栈上，如果不能，则分配在堆上。同时，go语言也提供了工具来辅助用户了解变量的分配情况
	- 使用-gcflags="-m"即可查看变量是否逃逸至堆上
	- 使用-gcflags="-m -m"能够查看详细的信息
	- 不管变量是否逃逸，万变不离其宗的是：如果在编译期就能够确定变量的生存周期和占用内存空间大小，那么该变量就应该被分配在栈上
6. 在接下来的内容中，我们将针对go语言的变量逃逸进行详细的分析
	
#### 举例
1. 运行hello.go，我们发现"Hello, World"字符串进行了逃逸，而其逃逸的原因是因为其被用作fmt.Println函数的参数，而这个函数的参数本身需要进行逃逸
```text
./hello.go:6: "Hello, World" escapes to heap
./hello.go:6: 	from ... argument (arg to ...) at ./hello.go:6
./hello.go:6: 	from *(... argument) (indirection) at ./hello.go:6
./hello.go:6: 	from ... argument (passed to call[argument content escapes]) at ./hello.go:6
./hello.go:6: main ... argument does not escape
```
